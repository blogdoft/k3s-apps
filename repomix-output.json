{
  "fileSummary": {
    "generationHeader": "This file is a merged representation of the entire codebase, combined into a single document by Repomix.\nThe content has been processed where empty lines have been removed.",
    "purpose": "This file contains a packed representation of the entire repository's contents.\nIt is designed to be easily consumable by AI systems for analysis, code review,\nor other automated processes.",
    "fileFormat": "The content is organized as follows:\n1. This summary section\n2. Repository information\n3. Directory structure\n4. Repository files, each consisting of:\n   - File path as a key\n   - Full contents of the file as the value",
    "usageGuidelines": "- This file should be treated as read-only. Any changes should be made to the\n  original repository files, not this packed version.\n- When processing this file, use the file path to distinguish\n  between different files in the repository.\n- Be aware that this file may contain sensitive information. Handle it with\n  the same level of security as you would the original repository.",
    "notes": "- Some files may have been excluded based on .gitignore rules and Repomix's configuration\n- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files\n- Files matching patterns in .gitignore are excluded\n- Files matching default ignore patterns are excluded\n- Empty lines have been removed from all files\n- Files are sorted by Git change count (files with more changes are at the bottom)"
  },
  "directoryStructure": "artifacts/\n  flagr/\n    deployment.yaml\n  longhorn/\n    helm-values/\n      values.yaml\n    manifests/\n      post-install.yaml\n  openbao/\n    helm-values/\n      values.yaml\n  redis/\n    apply.yaml\nplatform/\n  app-flagr.yaml\n  app-longhorn.yaml\n  app-openbao.yaml\n  app-plataform.yaml\n  app-redis.yaml\nREADME.md",
  "files": {
    "artifacts/longhorn/manifests/post-install.yaml": "kind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\n  name: longhorn-fast\nprovisioner: driver.longhorn.io\nallowVolumeExpansion: true\nreclaimPolicy: \"Delete\"\nvolumeBindingMode: Immediate\nparameters:\n  numberOfReplicas: \"1\"\n  staleReplicaTimeout: \"30\"\n  fsType: \"ext4\"\n  diskSelector: \"ssd\"\n  nodeSelector: \"ssd\"\n---\n# apiVersion: networking.k8s.io/v1\n# kind: Ingress\n# metadata:\n#   name: longhorn-frontend\n#   namespace: longhorn-system\n#   annotations:\n#     traefik.ingress.kubernetes.io/router.entrypoints: websecure\n#     traefik.ingress.kubernetes.io/router.tls: \"true\"\n# spec:\n#   ingressClassName: traefik\n#   tls:\n#     - hosts:\n#         - longhorn.home.arpa\n#       secretName: wildcard-home-arpa      \n#   rules:\n#     - host: longhorn.home.arpa\n#       http:\n#         paths:\n#           - path: /\n#             pathType: Prefix\n#             backend:\n#               service:\n#                 name: longhorn-frontend\n#                 port:\n#                   number: 80",
    "artifacts/redis/apply.yaml": "apiVersion: v1\nkind: Namespace\nmetadata:\n  name: redis-server\n--- \napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: redis-pvc\n  namespace: redis-server\nspec:\n  accessModes:\n    - ReadWriteOnce\n  storageClassName: longhorn-fast\n  resources:\n    requests:\n      storage: 5Gi\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: redis-server\n  namespace: redis-server\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: redis-server\n  template:\n    metadata:\n      labels:\n        app: redis-server\n        name: redis-server\n    spec:\n      nodeSelector:\n        node-type: worker\n      securityContext:\n        fsGroup: 1000\n      containers:\n      - name: redis-server\n        image: redis\n        securityContext:\n          runAsUser: 1000\n          runAsGroup: 1000\n        args: [\"--appendonly\", \"yes\", \"--requirepass\", \"eYVX7EwVmmxKPCDmwMtyKVge8oLd2t81\"]\n        livenessProbe:\n          tcpSocket:\n            port: 6379\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          tcpSocket:\n            port: 6379\n          initialDelaySeconds: 5\n          periodSeconds: 5\n        ports:\n          - name: redis-server\n            containerPort: 6379\n        volumeMounts:\n          - name: lv-storage\n            mountPath: /data\n        env:\n            - name: ALLOW_EMPTY_PASSWORD\n              value: \"yes\"\n        resources:\n          requests:\n            cpu: 100m\n            memory: 100Mi\n          limits:\n            cpu: 200m\n            memory: 512Mi              \n      volumes:\n        - name: lv-storage\n          persistentVolumeClaim:\n            claimName: redis-pvc\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: redis-server\n  namespace: redis-server\nspec:\n  selector:\n    app: redis-server\n  type: LoadBalancer\n  ports:\n    - name: redis-port\n      protocol: TCP\n      port: 6379\n      targetPort: 6379\n  loadBalancerIP: 192.168.1.212",
    "platform/app-openbao.yaml": "apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: openbao\n  namespace: argocd\nspec:\n  project: default\n  sources:\n    - repoURL: https://openbao.github.io/openbao-helm\n      chart: openbao\n      targetRevision: 0.21.2\n      helm:\n        valueFiles:\n          - $values/artifacts/openbao/helm-values/values.yaml\n    - repoURL: git@github.com:blogdoft/k3s-apps.git\n      targetRevision: HEAD\n      ref: values\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: openbao\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n      enabled: true\n    syncOptions:\n      - CreateNamespace=true",
    "platform/app-redis.yaml": "apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: redis\n  namespace: argocd\nspec:\n  project: default\n  source:\n    repoURL: git@github.com:blogdoft/k3s-apps.git\n    path: artifacts/redis\n    targetRevision: HEAD\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: redis-server\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n      enabled: true\n    syncOptions:\n      - CreateNamespace=true",
    "artifacts/flagr/deployment.yaml": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  namespace: flagr\n  name: flagr\n  labels:\n    app: flagr\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: flagr\n  template:\n    metadata:\n      labels:\n        app: flagr\n    spec:\n      containers:\n      - name: flagr\n        image: ghcr.io/openflagr/flagr:latest\n        ports:\n        - containerPort: 18000\n          name: http\n          protocol: TCP\n        env:\n        - name: FLAGR_DB_DBDRIVER\n          value: \"postgres\"\n        - name: POSTGRES_USER\n          valueFrom:\n            secretKeyRef:\n              name: postgres-credentials\n              key: POSTGRES_USER\n        - name: POSTGRES_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: postgres-credentials\n              key: POSTGRES_PASSWORD\n        - name: POSTGRES_HOST\n          valueFrom:\n            secretKeyRef:\n              name: postgres-credentials\n              key: POSTGRES_HOST\n        - name: POSTGRES_PORT\n          valueFrom:\n            secretKeyRef:\n              name: postgres-credentials\n              key: POSTGRES_PORT\n        - name: POSTGRES_DB\n          valueFrom:\n            secretKeyRef:\n              name: postgres-credentials\n              key: POSTGRES_DB\n        - name: FLAGR_DB_DBCONNECTIONSTR\n          value: \"host=$(POSTGRES_HOST) port=$(POSTGRES_PORT) user=$(POSTGRES_USER) password=$(POSTGRES_PASSWORD) dbname=$(POSTGRES_DB) sslmode=disable\"\n        resources:\n          requests:\n            memory: \"128Mi\"\n            cpu: \"100m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /api/v1/health\n            port: 18000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /api/v1/health\n            port: 18000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n---\napiVersion: v1\nkind: Service\nmetadata:\n  namespace: flagr\n  name: flagr\n  labels:\n    app: flagr\nspec:\n  type: ClusterIP\n  ports:\n  - port: 18000\n    targetPort: 18000\n    protocol: TCP\n    name: http\n  selector:\n    app: flagr\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  namespace: flagr\n  name: flagr\n  labels:\n    app: flagr\n  annotations:\n    traefik.ingress.kubernetes.io/router.entrypoints: web,websecure\n    traefik.ingress.kubernetes.io/router.middlewares: flagr-redirect-https@kubernetescrd\nspec:\n  ingressClassName: traefik\n  tls:\n  - hosts:\n    - flagr.home.arpa\n    secretName: wildcard-home-arpa\n  rules:\n  - host: flagr.home.arpa\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: flagr\n            port:\n              number: 18000\n---\napiVersion: traefik.io/v1alpha1\nkind: Middleware\nmetadata:\n  namespace: flagr\n  name: redirect-https\nspec:\n  redirectScheme:\n    scheme: https\n    permanent: true",
    "platform/app-flagr.yaml": "apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: flagr\n  namespace: argocd\nspec:\n  project: default\n  source:\n    repoURL: git@github.com:blogdoft/k3s-apps.git\n    path: artifacts/flagr\n    targetRevision: HEAD\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: flagr\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n      enabled: true\n    syncOptions:\n      - CreateNamespace=true",
    "platform/app-longhorn.yaml": "apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: longhorn\n  namespace: argocd\nspec:\n  project: default\n  sources:\n    - repoURL: https://charts.longhorn.io\n      chart: longhorn\n      targetRevision: 1.10.1\n      helm:\n        valueFiles:\n          - $values/artifacts/longhorn/helm-values/values.yaml\n    - repoURL: git@github.com:blogdoft/k3s-apps.git\n      path: artifacts/longhorn/manifests\n      targetRevision: HEAD\n      ref: values\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: longhorn-system\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n      enabled: true\n    syncOptions:\n      - CreateNamespace=true",
    "platform/app-plataform.yaml": "apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: platform\n  namespace: argocd\nspec:\n  project: default\n  source:\n    repoURL: git@github.com:blogdoft/k3s-apps.git\n    path: platform\n    targetRevision: HEAD\n  destination:\n    server: https://kubernetes.default.svc\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n      enabled: true\n    syncOptions:\n      - CreateNamespace=true",
    "README.md": "# k3s-apps\n\nThis repository contains the **desired state** (GitOps) of the services running in my **k3s** cluster, all managed by **Argo CD**.\nThe idea is straightforward: everything that is running in the cluster is declared here, and Argo CD continuously reconciles the cluster with this repository.\n\nThe structure is organized as follows:\n\n* `platform/`: **Argo CD Applications**, including the *root app* (App of Apps pattern)\n* `artifacts/`: raw Kubernetes manifests and **Helm values** per service\n\n---\n\n## Deployed services and URLs\n\n### Longhorn (distributed storage)\n\n* **URL:** `https://longhorn.home.arpa/`\n* Installed via the official Helm chart, with custom values and additional manifests stored in this repository.\n\n### OpenBao (Vault-compatible secrets management)\n\n* **URL:** `https://openbao.home.arpa/ui`\n* UI enabled and exposed via Ingress.\n* TLS is terminated at the Ingress level (internal TLS disabled in the chart).\n\n### Flagr (feature flags)\n\n* **URL:** `https://flagr.home.arpa/`\n* Exposed via Ingress with HTTPS redirection.\n* Health check endpoint:\n  `GET /api/v1/health`\n\n### Redis\n\n* **Access:** `192.168.1.212:6379` (Service type `LoadBalancer`)\n* Persistent storage backed by a PVC using the `longhorn-fast` StorageClass.\n\n---\n\n## Cluster prerequisites\n\nBefore applying anything from this repository, the cluster must meet the following requirements:\n\n1. **Argo CD installed** in the `argocd` namespace.\n2. **SSH access to this repository** configured in Argo CD\n   (`git@github.com:blogdoft/k3s-apps.git`).\n3. **Traefik as the Ingress Controller**\n   (Ingress manifests rely on `ingressClassName: traefik` and Traefik annotations).\n4. **Wildcard TLS certificate**\n   A Secret named `wildcard-home-arpa` must exist in the namespaces where HTTPS is required (Longhorn, OpenBao, Flagr).\n5. **Internal DNS** resolving `*.home.arpa` to the Traefik entrypoint (Ingress / LoadBalancer IP).\n6. **Longhorn disk and node labeling**\n   This repo defines a custom StorageClass `longhorn-fast` with:\n\n   * `numberOfReplicas: \"1\"`\n   * `diskSelector: ssd`\n   * `nodeSelector: ssd`\n     Nodes and disks must be labeled accordingly.\n\n---\n\n## Applying everything (GitOps – App of Apps)\n\nThe main entry point is the **root application** defined in:\n\n```\nplatform/app-plataform.yaml\n```\n\nThis application points back to the `platform/` directory in this repository and automatically creates and manages all child applications (Longhorn, OpenBao, Flagr, Redis).\n\nRecommended flow:\n\n1. Ensure Argo CD can access the repository via SSH.\n2. Apply the root application:\n\n```bash\nkubectl apply -n argocd -f platform/app-plataform.yaml\n```\n\n3. Argo CD will automatically create and synchronize all child applications.\n   All of them use:\n\n   * automated sync\n   * `prune: true`\n   * `selfHeal: true`\n   * `CreateNamespace: true`\n\n---\n\n## Application details\n\n### `platform/app-longhorn.yaml`\n\n* Installs Longhorn via Helm.\n* Applies additional manifests from `artifacts/longhorn/manifests`.\n* Defines the `longhorn-fast` StorageClass after installation.\n\n### `platform/app-openbao.yaml`\n\n* Installs OpenBao via Helm.\n* Uses versioned values stored in this repository.\n* Exposes the UI at `openbao.home.arpa`.\n\n### `platform/app-flagr.yaml`\n\n* Deploys Flagr using raw manifests from `artifacts/flagr/deployment.yaml`.\n* Exposes the service at `flagr.home.arpa` with HTTPS enforcement.\n\n### `platform/app-redis.yaml`\n\n* Deploys Redis using manifests from `artifacts/redis/apply.yaml`.\n* Exposes Redis via a `LoadBalancer` with a fixed IP (`192.168.1.212`).\n\n---\n\n## Secrets and sensitive configuration\n\n### Flagr – PostgreSQL credentials\n\nThe Flagr deployment expects a Secret named `postgres-credentials` in the `flagr` namespace with the following keys:\n\n* `POSTGRES_USER`\n* `POSTGRES_PASSWORD`\n* `POSTGRES_HOST`\n* `POSTGRES_PORT`\n* `POSTGRES_DB`\n\n**Recommendation:**\nDo not commit real values to Git. Prefer solutions such as OpenBao, External Secrets, Sealed Secrets, or SOPS.\n\n### Redis – hardcoded password (important)\n\nRedis is currently configured with `--requirepass` directly in the manifest, which means the password is **stored in Git**.\n\nThis is not recommended. A better approach would be:\n\n* Move the password to a Kubernetes Secret.\n* Inject it via environment variables or command arguments.\n\nAdditionally, `ALLOW_EMPTY_PASSWORD=\"yes\"` is set, which is usually unnecessary and can be misleading from a security standpoint.\n\n---\n\n## Operations and quick troubleshooting\n\n* List Argo CD applications:\n\n  ```bash\n  kubectl get applications -n argocd\n  ```\n\n* List all Ingress resources:\n\n  ```bash\n  kubectl get ingress -A\n  ```\n\n* Check Flagr health:\n\n  ```bash\n  curl -k https://flagr.home.arpa/api/v1/health\n  ```\n\n* Inspect Redis service:\n\n  ```bash\n  kubectl -n redis-server get svc redis-server\n  ```\n\n---\n\n## Suggested improvements / roadmap\n\n* Remove hardcoded Redis credentials and standardize secret management.\n* Ensure the `wildcard-home-arpa` TLS Secret exists in all required namespaces.\n* Document and standardize node and disk labeling for Longhorn (`ssd` selectors).\n* Optionally add a small `README.md` per service under `artifacts/<service>/` describing configuration, backup, and restore procedures.",
    "artifacts/longhorn/helm-values/values.yaml": "ingress:\n  enabled: true\n  ingressClassName: traefik\n  host: longhorn.home.arpa\n  path: /\n  pathType: Prefix\n  tls: true\n  tlsSecret: wildcard-home-arpa\n  annotations:\n    traefik.ingress.kubernetes.io/router.entrypoints: websecure\n    traefik.ingress.kubernetes.io/router.tls: \"true\"\npersistence:\n  defaultClass: false \ndefaultSettings:\n  defaultDataPath: \"/storage01\"\nservice:\n  ui:\n    type: \"ClusterIP\"\npreUpgradeChecker:\n  jobEnabled: false\n  upgradeVersionCheck: false",
    "artifacts/openbao/helm-values/values.yaml": "server:\n  # Habilitar a UI\n  ui:\n    enabled: true\n    serviceType: ClusterIP\n  # Configuração standalone com UI habilitada\n  standalone:\n    enabled: true\n    config: |\n      ui = true\n      listener \"tcp\" {\n        tls_disable = 1\n        address = \"[::]:8200\"\n        cluster_address = \"[::]:8201\"\n      }\n      storage \"file\" {\n        path = \"/openbao/data\"\n      }\n  ingress:\n    enabled: true\n    ingressClassName: traefik\n    annotations:\n      traefik.ingress.kubernetes.io/router.entrypoints: web,websecure\n    hosts:\n      - host: openbao.home.arpa\n        paths:\n          - /\n    tls:\n      - hosts:\n          - openbao.home.arpa\n        secretName: wildcard-home-arpa\n  dataStorage:\n    storageClass: \"longhorn-fast\"\n  auditStorage:\n    storageClass: \"longhorn-fast\"\n# Desabilitar TLS global (gerenciado pelo Ingress)\nglobal:\n  tlsDisable: true"
  }
}